/**********************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************* LICENSE ************************************************************************************************************/
/**********************************************************************************************************************************************************************************************************************************/
//
//    Copyright © 2016 Bastien Pasdeloup (name.surname@gmail.com) and Télécom Bretagne
//
//    This file is part of PyRat.
//
//    PyRat is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    PyRat is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with PyRat.  If not, see <http://www.gnu.org/licenses/>.
//
/**********************************************************************************************************************************************************************************************************************************/
/****************************************************************************************************** INCLUDES & NAMESPACES *****************************************************************************************************/
/**********************************************************************************************************************************************************************************************************************************/

    /** EXTERNAL **/
    #include <string>
    #include <tuple>
    #include <unordered_map>
    #include <unordered_set>
    #include <vector>
    
    /** INTERNAL **/
    #include <Shell.cpp>
    
    /** NAMESPACES **/
    using namespace std;

/**********************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************** CLASS *************************************************************************************************************/
/**********************************************************************************************************************************************************************************************************************************/
    
    #ifndef _ARGUMENTS_PARSER_
    #define _ARGUMENTS_PARSER_
        
        class ArgumentsParser
        {
            
            /**********************************************************************************************************************************************************************************************************/
            /********************************************************************************************** CONSTRUCTORS **********************************************************************************************/
            /**********************************************************************************************************************************************************************************************************/
                
                /** DOCUMENTATION **/
                // Default constructor
                
                /** CODE **/
                public : ArgumentsParser ()
                {}
            
            /**********************************************************************************************************************************************************************************************************/
            /*********************************************************************************************** DESTRUCTOR ***********************************************************************************************/
            /**********************************************************************************************************************************************************************************************************/
                
                /** DOCUMENTATION **/
                // Empty destructor
                
                /** CODE **/
                public : virtual ~ArgumentsParser ()
                {}
                
            /**********************************************************************************************************************************************************************************************************/
            /************************************************************************************************* METHODS ************************************************************************************************/
            /**********************************************************************************************************************************************************************************************************/
                
                /** DOCUMENTATION **/
                // Parses the command line to return the arguments in an easier to consider structure
                // If the optional arguments are not here, the defaut values are set
                // If some compulsory arguments are missing, an error is issued
                
                /** CODE **/
                public : unordered_map<string, tuple<bool, string>> argumentsToMap (int argc, char** argv, unordered_set<string> compulsoryArguments, unordered_map<string, string> optionalArguments)
                {
                    
                    // We manipulate a vector
                    vector<string> arrayToParse;
                    arrayToParse.assign(argv, argv + argc);
                    
                    // We iterate over the vector to find the arguments
                    unordered_map<string, tuple<bool, string>> result;
                    for (unsigned int i = 0 ; i < arrayToParse.size() - 1 ; i++)
                    {
                        string key = arrayToParse[i];
                        string value = arrayToParse[i + 1];
                        bool alreadyExists = result.find(key) != result.end();
                        if (alreadyExists)
                            Shell::getInstance().warning("Multiple instances of argument " + key);
                        bool isCompulsory = compulsoryArguments.find(key) != compulsoryArguments.end();
                        bool isOptional = optionalArguments.find(key) != optionalArguments.end();
                        if (isCompulsory || isOptional)
                            result[key] = make_tuple(true, value);
                    }
                    
                    // We check that all compulsory arguments have been set
                    for (auto& key : compulsoryArguments)
                    {
                        bool keyExists = result.find(key) != result.end();
                        if (!keyExists)
                            Shell::getInstance().error("Compulsory argument " + key + " is not set");
                    }
                    
                    // We assign default values to all unset optional arguments
                    for (auto& keyValue : optionalArguments)
                    {
                        bool keyExists = result.find(keyValue.first) != result.end();
                        if (!keyExists)
                            result[keyValue.first] = make_tuple(false, keyValue.second);
                    }
                    
                    // Done
                    return result;
                    
                }
            
            /**********************************************************************************************************************************************************************************************************/
            /**********************************************************************************************************************************************************************************************************/
            
        };
        
    #endif

/**********************************************************************************************************************************************************************************************************************************/
/**********************************************************************************************************************************************************************************************************************************/
